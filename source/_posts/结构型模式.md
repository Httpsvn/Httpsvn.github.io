---
title: 结构型模式
date: 2020-03-23 12:06:57
tags: [设计模式,结构型模式]
---

生物的`进化`，是否可以应对环境的`变化`，这取决于一开始是否有良好的结构，或者是否进化出了良好的结构。 上帝不掷骰子。
---

## 适配器模式

中国的标准电压是220V,美国的标准电压是110V,当我们使用美国生成的110V电压的设备的时候，应该连接一个适配器。

> 使得原本由于接口不兼容而吧不能一起工作的那些类可以一起工作

个人认为，适配器模式更多的应该应用于`跨系统`或`跨语言`，单纯的同一种代码实现适配器系统并没有什么实际的意义（这种请求下更像是请求转发）。故不在进行过多解释。

## 桥接模式

观点斗争是假的、方向斗争也是假的，只有利益斗争才是真的。   

当我们调用类的时候，我们并不关心细节的实现，关心得是他们之间的联系。

>将聚合关系建立在抽象层，这样实现细节于现实分离。

以包作为列子，包可能是挎包，背包，颜色可能是黄色，蓝色

创建包的抽象类
```

abstract class Bag
{
    protected Color color;
    public void setColor(Color color)
    {
        this.color=color;
    }   
    public abstract String getName();
}

```

扩展包
```
//扩展抽象化角色：挎包
class HandBag extends Bag
{
    public String getName()
    {
        return color.getColor()+"HandBag";
    }   
}
//扩展抽象化角色：钱包
class Wallet extends Bag
{
    public String getName()
    {
        return color.getColor()+"Wallet";
    }   
}
```

创建颜色的抽象类
```
//实现化角色：颜色
interface Color
{
    String getColor();
}
```

扩展颜色
```
//具体实现化角色：黄色
class Yellow implements Color
{
    public String getColor()
    {
        return "yellow";
    }
}
//具体实现化角色：红色
class Red implements Color
{
    public String getColor()
    {
        return "red";
    }
```

客户端调用

```
class Client{

   public void main(){
   
     Color  yellow  = new Yellow();
     Bag handBag = new HandBag(yellow)
     Color  red  = new Red();
     Bag wallet = new Wallet(red)     

   }

}

```

因为我们在抽象层已经确定了`颜色是对包`的修饰，所以不会出现`包对颜色`的修饰。

但是`桥接模式`的缺点就是它的优点，因为在抽象层固化了连接关系，所以如果关系发生改变，那么细节必然也会发生改变。

## 组合模式

公司再大都叫公司，鱼再小都叫鱼。（世界上没有一种草，叫草 😂）

>它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。


我们不管访问一个公司的还是它的子公司，都可以看做访问相同的结构的对象。

建立一个公司的抽象:

```
abstract class Component{

string name;

public Component(String name){
    this.name=name;
}

public abstract void Add(Component c)

}
```

创建两个公司

``` 
class AComponent :Component{
    
    string name;
    Component childComponent;
    public AComponent(string name):base(name){
        this.name=name;
        }

    public void Add(Component c){
        childComponent=c；
        }

}


class BComponent :Component{
    
    string name;
    Component childComponent;
    public AComponent(string name):base(name){
        this.name=name;
        }

    public void Add(Component c){
        childComponent=c；
        }

}
```

客户端调用
```
class Client{
   public void main(){
        Component  headComponent= new AComponent();
        Component  bComponent= new BComponent();
        // 收购bComponent公司
        headComponent.Add(bComponent);

        }
}
```

我们访问的都是两个具体的公司，但我们访问的方式是一致的。组合模式的难点在于`理清类之间的层次关系`。



## 装饰模式

>在不改变现有对象结构的情况下，动态地给该对象增加一些`职责`（即增加其额外功能）的模式，它属于对象结构型模式。

这样的好处在于采用装饰模式扩展对象的功能比采用继承方式更加灵活，但是如果装饰类过多，类依然爆炸

抽象构件角色
```
public interface Component {


    public void  operation();

}

```
构件角色

```
public class Knight implements  Component {
    String name;

    public Knight(String name) {
        this.name = name;
    }
    @Override
    public void operation() {
        System.out.println("骑士"+name+"出发");
    }
}

```
构件装饰

```
// 装一把剑
public class Sword implements  Component {
    Component component;

    public Sword(Component component) {

        this.component = component;
    }

    @Override
    public void operation() {

        if (component!=null){
            System.out.println("拿上🗡");
            component.operation();
        }
    }
}

//骑一匹马

public class Horse implements Component {

    Component component;

    public Horse(Component component) {

        this.component = component;
    }

    @Override
    public void operation() {

        if (component!=null){
            System.out.println("骑上马");
            component.operation();
        }
    }
}

```

开始构建

```
public class Client {
    public static void main(String[] args) {
        Knight knight = new Knight("亚瑟");
        Horse horse= new Horse(knight);
        Sword sword= new Sword(horse);
        sword.operation();
    }
}
//结果
拿上🗡
骑上马
骑士亚瑟出发
```

不用扩展复写子类完成对功能的扩展。

## 外观模式

代理访问，原理客户端要访问的一系列类，交由外观模式带由访问，就是整合访问代码到一个新的类里面，保存调用界面干净。

## 享元模式

>运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。

享元模式中由`享元角色`和`非享元角色`构成

来一盘五子棋,棋子中的白子、黑子，是享元角色，而位置是非享元角色

抽象棋子角色
```
public interface ChessPieces {
    public void  DownPieces(Point point);
}

```
具体化棋子对象
```
// 白棋
public class WhitePieces implements  ChessPieces {
    @Override
    public void DownPieces(Point point) {
        System.out.println("在"+point.x+"/"+point.y+"落下白子");
    }
}

//黑棋
public class BlackPieces implements  ChessPieces {
    @Override
    public void DownPieces(Point point) {
        System.out.println("在"+point.x+"/"+point.y+"落下黑子");
    }
}

```

通过共享工厂，共享`享元角色`
```


public class WeiqiFactory {

    private ArrayList<ChessPieces> qz;

    public WeiqiFactory() {

        qz = new ArrayList<>();
        ChessPieces w = new WhitePieces();
        ChessPieces b = new BlackPieces();
        qz.add(w);
        qz.add(b);

    }

    public ChessPieces getChessPieces(String tag) {
        ChessPieces chessPieces;
        if (tag.equals("w")) {
            chessPieces = qz.get(0);
        } else {
            chessPieces = qz.get(1);
        }


        return chessPieces;
    }

}


```

客户端实现:
```
import java.awt.*;

public class Client {
    public static void main(String[] args) {


        WeiqiFactory weiqiFactory = new WeiqiFactory();

        ChessPieces wqz=  weiqiFactory.getChessPieces("w");
        ChessPieces bqz=  weiqiFactory.getChessPieces("b");
        wqz.DownPieces(new Point(10,20));
        bqz.DownPieces(new Point(50,20));
    }
}

结果：
在10/20落下白子
在50/20落下黑子

```

## 代理模式

给某对象提供一个代理以控制对该对象的访问。
```
package proxy;
public class ProxyTest
{
    public static void main(String[] args)
    {
        Proxy proxy=new Proxy();
        proxy.Request();
    }
}
//抽象主题
interface Subject
{
    void Request();
}
//真实主题
class RealSubject implements Subject
{
    public void Request()
    {
        System.out.println("访问真实主题方法...");
    }
}
//代理
class Proxy implements Subject
{
    private RealSubject realSubject;
    public void Request()
    {
        if (realSubject==null)
        {
            realSubject=new RealSubject();
        }
        preRequest();
        realSubject.Request();
        postRequest();
    }
    public void preRequest()
    {
        System.out.println("访问真实主题之前的预处理。");
    }
    public void postRequest()
    {
        System.out.println("访问真实主题之后的后续处理。");
    }
}
```

参考资料：

* [C语言中文网](http://c.biancheng.net/design_pattern/ "C语言中文网 设计模式")
* [大话设计模式](https://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262 "大话设计模式 实体书")
