---
title: 创建型模式
date: 2020-03-21 16:13:06
tags: [设计模式,创建型模式]
---

我们好奇一个事物的创建过程，但在想是使用它的时候，我们更需要简单的得到。
---

## 简单工厂模式

由一个类提供一个方法，通过传入的参数来实例化请求对象。也就是说判断实例化哪个对象，是在这个类内部进行的。
```java 
Class Arithmetic{
        

    public  void CreateSymbol(string tag){
        Symbol symbol;
        switch(tag){
           case "+":
            sysmbol =new Add();
           break;
           case "-":
            sysmbol =new Less();
           break;        
            }

      }

}
```
这样我们只需要提供一个字符串就可以进行实列化了，的确很`简单`。但无数次经验告诉我们，`简单和好用永远不会出现在对一个物体的修饰上，而且这种修饰还是实话`。  

在`简单工厂模式`扩展一种功能，比如所除,这时我们不得不对已经写好的代码进行`修改`。对，这种模式下对于功能的扩展只有进行修改，这明显违背了`开放-封闭原则`。虽然这种修改带来的代价在以上的代码上看来无足轻重，那么随着功能的增加(比如定义一个新的算数规则，这个规则需要传递两个参数才能进行实列化,在修改传创建方法的同时，以前使用简单工厂创建对象的地方是否也要进行修改)。

## 工厂模式

> 定义一个用于创建对象的接口，让子类决定实列化哪一个类。

我们必须明白，工厂是生产东西的地方，不管什么样的工厂都应当有个输出产品的地方，`我们`要找什么样的工厂是要进行判断的。  
所以基于以上得出两个事实：
1. 工厂应当有一个输出接口
2. 判断是必须的
所以产生了工厂模式。

定义一个工厂输出接口
```
interface IFactory{
    Symbol CreateSymbol();
}
```

定义简单运算类
```
//简单
class SimpleSymbolFactory : IFactory{

    String tag
    
    SimpleSymbolFactory(String str){
        tag=str;
        }
       
    public Symbol CreateSymbol(){
      Symbol symbol;
       if(tag.isNotEmpty){
           switch(tag){
             case "+":
             sysmbol =new Add();
             break;
             case "-":
             sysmbol =new Less();
             break;        
            }
        }
       return symbol;
      }

}
```

定义自定义运算类
```
//简单
class CustomizeSymbolFactory : IFactory{

    String A;
    String B;
    
    SimpleSymbolFactory(String a ,String b){
        A=a;
        B=b;
        }
       
    public Symbol CreateSymbol(){
      Symbol symbol= new CustomizeSymbol(A,B)
      return symbol;
      }

}
```

客户端调用
```
    class Client{
       public void main(){
         IFactory simpleSymbolFactory = new SimpleSymbolFactory("+")
         Symbol add = simpleSymbolFactory.CreateSymbol();
          //切换工厂类
         IFactory customizeSymbolFactory = new CustomizeSymbolFactory("1","2")
         Symbol cus = customizeSymbolFactory.CreateSymbol();
       }
    }
```
首先调用的时候只需要切换工厂类，其次如果出现需要三个参数的运算的时候，我们只需要定义对应的类和工厂，切换工厂类即可。`不会修改`原来已经写好的工厂类，`功能扩展代码扩展`。

## 抽象工厂模式

在`工厂模式`中，这样有这样一段话：

> 我们必须明白，工厂是生产东西的地方，不管什么样的工厂都应当有个输出产品的地方，<font color=#ff0000 size=3>我们</font>要找什么要的工厂是要进行判断的。

就像我们实际上并不关心具体是哪个工厂一样,工厂也不关心<font color=#ff0000 size=3>我们</font>是谁，我们与工厂的关系概况就是：抽象的需求者向工厂提出需求，工厂负责生产。提出者和工厂都可以是抽象，耦合的只有他们之间的关系。

>提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类。

创建一个生产巧克力的接口
```
    interface IFactory{
       Chocolate CreateChocolate();
      }
```
实现创建两个巧克力工厂分别生产德芙和金帝
```
    class AFactory:IFactory{

        public Chocolate CreateChocolate(){
           return new 德芙()
          }
      
      }

    class BFactory:IFactory{

        public Chocolate CreateChocolate(){
           return new 金帝()
          }
      
      }

```

客户端调用

```

class Client{

   public void main(){
     IFactory af = new AFactory()
     Chocolate chA= af.CreateChocolate();

     IFactory bf = new BFactory()
     Chocolate chB= bf.CreateChocolate();
     //只需要切换工厂生产的巧克力就有不一样了
     print(小红买的是+chA)
     print(小明买的是+chB)
   }

}

```

这个与`工厂模式`的不同在于，`工厂模式`只关心对于`工厂`的扩展，而`抽象工厂`开始注意工厂与需求者之间的交互，这样使得我们仅通过抽象就可大致明白类之间的关系。
  
但是如果过于在意之间的交互，必然耦合严重，只要`知道` `耦合的是关系`，并`不是具体的类`，这就是`抽象工厂`的核心

<font color=#ff0000 size=15>但是</font>  

`抽象工厂`有一个致命的缺点：可以扩展种类，极难扩展业务。  

比如我要一个工厂生产徐福记巧克力，我写一个工厂类，一个巧克力的类，就可以了。  
但如果我要工厂开始生产奶糖，必然要修改工厂接口，那么其他工厂也必须进行修改。  
这个问题可以通过将`IFactory`接口修改成抽象类，其中生产奶糖的不是抽象方法，实现工厂的时候可以实现需要的方法即可，在客户端进行判断这里是不是卖奶糖。























    


