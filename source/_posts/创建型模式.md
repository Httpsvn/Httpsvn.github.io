---
title: 创建型模式
date: 2020-03-21 16:13:06
tags: [设计模式,创建型模式]
---

我们好奇一个事物的创建过程，但在想是使用它的时候，我们更需要简单的得到。
---

## 简单工厂模式

由一个类提供一个方法，通过传入的参数来实例化请求对象。也就是说判断实例化哪个对象，是在这个类内部进行的。
```java 
Class Arithmetic{
        

    public  void CreateSymbol(string tag){
        Symbol symbol;
        switch(tag){
           case "+":
            sysmbol =new Add();
           break;
           case "-":
            sysmbol =new Less();
           break;        
            }

      }

}
```
这样我们只需要提供一个字符串就可以进行实列化了，的确很`简单`。但无数次经验告诉我们，`简单和好用永远不会出现在对一个物体的修饰上，而且这种修饰还是实话`。  

在`简单工厂模式`扩展一种功能，比如所除,这时我们不得不对已经写好的代码进行`修改`。对，这种模式下对于功能的扩展只有进行修改，这明显违背了`开放-封闭原则`。虽然这种修改带来的代价在以上的代码上看来无足轻重，那么随着功能的增加(比如定义一个新的算数规则，这个规则需要传递两个参数才能进行实列化,在修改传创建方法的同时，以前使用简单工厂创建对象的地方是否也要进行修改)。

## 工厂模式

> 定义一个用于创建对象的接口，让子类决定实列化哪一个类。

我们必须明白，工厂是生产东西的地方，不管什么样的工厂都应当有个输出产品的地方，`我们`要找什么样的工厂是要进行判断的。  
所以基于以上得出两个事实：
1. 工厂应当有一个输出接口
2. 判断是必须的
所以产生了工厂模式。

定义一个工厂输出接口
```
interface IFactory{
    Symbol CreateSymbol();
}
```

定义简单运算类
```
//简单
class SimpleSymbolFactory : IFactory{

    String tag
    
    SimpleSymbolFactory(String str){
        tag=str;
        }
       
    public Symbol CreateSymbol(){
      Symbol symbol;
       if(tag.isNotEmpty){
           switch(tag){
             case "+":
             sysmbol =new Add();
             break;
             case "-":
             sysmbol =new Less();
             break;        
            }
        }
       return symbol;
      }

}
```

定义自定义运算类
```
//简单
class CustomizeSymbolFactory : IFactory{

    String A;
    String B;
    
    SimpleSymbolFactory(String a ,String b){
        A=a;
        B=b;
        }
       
    public Symbol CreateSymbol(){
      Symbol symbol= new CustomizeSymbol(A,B)
      return symbol;
      }

}
```

客户端调用
```
    class Client{
       public void main(){
         IFactory simpleSymbolFactory = new SimpleSymbolFactory("+")
         Symbol add = simpleSymbolFactory.CreateSymbol();
          //切换工厂类
         IFactory customizeSymbolFactory = new CustomizeSymbolFactory("1","2")
         Symbol cus = customizeSymbolFactory.CreateSymbol();
       }
    }
```
首先调用的时候只需要切换工厂类，其次如果出现需要三个参数的运算的时候，我们只需要定义对应的类和工厂，切换工厂类即可。`不会修改`原来已经写好的工厂类，`功能扩展代码扩展`。

## 抽象工厂模式

在`工厂模式`中，这样有这样一段话：

> 我们必须明白，工厂是生产东西的地方，不管什么样的工厂都应当有个输出产品的地方，<font color=#ff0000 size=3>我们</font>要找什么要的工厂是要进行判断的。

就像我们实际上并不关心具体是哪个工厂一样,工厂也不关心<font color=#ff0000 size=3>我们</font>是谁，我们与工厂的关系概况就是：抽象的需求者向工厂提出需求，工厂负责生产。提出者和工厂都可以是抽象，耦合的只有他们之间的关系。

>提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类。

创建一个生产巧克力的接口
```
    interface IFactory{
       Chocolate CreateChocolate();
      }
```
实现创建两个巧克力工厂分别生产德芙和金帝
```
    class AFactory:IFactory{

        public Chocolate CreateChocolate(){
           return new 德芙()
          }
      
      }

    class BFactory:IFactory{

        public Chocolate CreateChocolate(){
           return new 金帝()
          }
      
      }

```

客户端调用

```

class Client{

   public void main(){
     IFactory af = new AFactory()
     Chocolate chA= af.CreateChocolate();

     IFactory bf = new BFactory()
     Chocolate chB= bf.CreateChocolate();
     //只需要切换工厂生产的巧克力就有不一样了
     print(小红买的是+chA)
     print(小明买的是+chB)
   }

}

```

这个与`工厂模式`的不同在于，`工厂模式`只关心对于`工厂`的扩展，生产同等级的产品(生成的都是Symbol)，而`抽象工厂`抽象类中的相同业务。
  
但是如果过于在意之间的交互，必然耦合严重，只要`知道` `耦合的是关系`，并`不是具体的类`，这就是`抽象工厂`的核心

<font color=#ff0000 size=15>但是</font>  

`抽象工厂`有一个致命的缺点：可以扩展种类，极难扩展业务。  

比如我要一个工厂生产徐福记巧克力，我写一个工厂类，一个巧克力的类，就可以了。  
但如果我要工厂开始生产奶糖，必然要修改工厂接口，那么其他工厂也必须进行修改。  
这个问题可以通过将`IFactory`接口修改成抽象类，其中生产奶糖的不是抽象方法，实现工厂的时候可以实现需要的方法即可，在客户端进行判断这里是不是卖奶糖。


## 建造者模式

`生活`还是`活着`这是一个问题
---

我们的`活着`是由基础的生活资料构成，这些必不可少，而后自由、文明构成了`生活`的环境。`生活`标准虽然在每个时代是不同的，但作为人类确是相同的。


>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

```
class Person {

   Person(食物，水，空气){

       }

   public void 自由(){
        this.自由=true;    
        }

   public void 文明(){
        this.文明=true;   
        }

   public void 人权(){
        this.人权=true;   
        }
}

```

当我们构建一个古人类的时候只需要为他提供基础的生活资料:

```
Person 古人类 =new Person(食物，水，空气)
```

但我们构建一个现代人的时候,我们将为他提供`生活`所必要的东西:
```
Person 现代人 =new Person(食物，水，空气)
现代人.自由()
现代人.文明()
现代人.人权()
```

通过以上可以知道，`建造者模式`通过保留核心，扩展特性，完成构建。我们如果需要构建一个超人添加一个超能力的属性即可，构造其他的人类的代码可以不进行修改。

但是把所有的构造过程展示在客户端，这样并不优雅。

客户端的目的是想要一个超人，构建过程客户端并不关心，所以结合`工厂模式`修改代码

```

abstract class PersonBuilder{

         Person(食物，水，空气){
       
           } 
   public abstract void 自由();
   public abstract void 文明();
   public abstract void 人权();
   public abstract void 超能力();

}

```
超人类
```

class SuperMan : PersonBuilder(){

   SuperMan(食物，水，空气):base(食物，水，空气){

       }

   public void 自由(){
        this.自由=true;    
        }

   public void 文明(){
        this.文明=true;   
        }

   public void 人权(){
        this.人权=true;   
        }

   public void 超能力(){
        this.人权=true;   
        }

}

```

再有`工厂`提供出去

```
 public PersonFactory{

     PersonBuilder personBuilder;
   
     PersonFactory(PersonBuilder personBuilder){
            this.personBuilder=personBuilder
      }

     public void CreatePerson(){

        personBuilder.自由();
        personBuilder.文明();
        personBuilder.人权();
        personBuilder.超能力();

        }
     
    
   }
```

客户端调用

```

Person 超人 =new SuperMan(食物，水，空气);
PersonFactory 超人工厂 = new  PersonFactory(超人);
超人工厂.CreatePerson();



Person 古人类 =new SuperMan(食物，水，空气);
//古人类 属性都是false
PersonFactory 古人类 = new  PersonFactory(超人);
古人类.CreatePerson();

```

对于以后的扩展我们可以对不抽象方法，来实现扩展。


## 原型模式

当对象相同或相似的时候，当创建一个类相对麻烦的时候，可以用复制解决。原型模式的实现方式，就是通过实现语言的克隆方法，实现对对象的复制。

这种克隆对于语言而言，大多是浅拷贝，只能复制对象中非引用类型的对象。

```

    class Person{
       string name;
       string age;
       Gift gift;
    }
// 客户端
Person p1= new Person();
p1.gift= new Gift("美术");
Person p2 = p1.clone();
//这是 p2.gift是空的
```

## 单例模式

你是我世界的唯一
---

为了节约资源，保存内容的一直性，对某些类要求只能创建一个实例对象。

单例的阐述到此为止，我相信大多数人学习的一个设计模式就是单例模式。

### 单列的写法

1. 懒汉式单例

```
public class LazySingleton
{
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton(){}    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance()
    {
        //getInstance 方法前加同步
        if(instance==null)
        {
            instance=new LazySingleton();
        }
        return instance;
    }
}

```
注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。

2. 饿汉式单例
```
public class HungrySingleton
{
    private static final HungrySingleton instance=new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance()
    {
        return instance;
    }
}
```

饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。





参考资料：

* [C语言中文网](http://c.biancheng.net/design_pattern/ "C语言中文网 设计模式")
* [大话设计模式](https://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262 "大话设计模式 实体书")





















    


